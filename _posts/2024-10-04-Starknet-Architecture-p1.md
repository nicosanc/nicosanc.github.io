
### Architecture
Cairo Smart Contracts compiles into -> **SIERRA** (Safe Intermediate Representation) compiles into -> **CASM** (Safe Cairo Assembly) generates -> **Validity Proof**
- Failed transactions are included in the blocks
- Sequencer always compensated 
- No more DoS vector as in Cairo0

![image](https://github.com/nicosanc/nicosanc.github.io/blob/main/assets/images/sn2.jpg)

This is how StarkNet does it 

![image](https://github.com/nicosanc/nicosanc.github.io/blob/main/assets/images/sn1.jpg)

The prover is run in a separate module called SHARP (Shared Prover)
- ETH Verifier

### Order of executions
- **Sequencer** bundles all the transactions, executing them, generating new block with new state, creates an execution trace that is sent to SHARP
	- Done with a Cairo program called StarkNet OS
- The **Prover** generates the validity proof and sends it to Starknet and StarkEx on L1
	- If it is accepted as true, then the new state generated by the sequencer is sent to Ethereum
	- The idea is you don't wanna update the state of the blockchain until an execution or the sequence of executions' proof is verified
- **Full Nodes** get the latest block from the sequencer
	- Used to get the data for your L2 Dapp
- **Starknet Core** is an L1 smart contract that stores changes to L2 global state 
- **Verifier** is an L1 smart contract that verifies validity proofs from SHARP

### Transactions

**3 TX types**:
1) **Deploy_account**
	- Deploys an account contract
2) **Declare**
	- Registers the Sierra code of a SC
3) **Invoke**
	- Executes write functions
	- modifies the global state
	- Requires paying gas fees
*Read Only functions are not considered transactions since they don't modify state, thus no gas fees*
 
**Declaring and Deploying**
- Declaring registers Sierra code on L2
- Declared code is aka "contract class"
	- Contract classes don't have internal storage
	- Used as a definition of the class, not an instance
- From blueprint a smart contract instance can be deployed
- contract instances have internal storage
- Every instance has a diff address

**Universal Deployer**
- Smart contract on StarkNet that deploys other smart contract
- Only one selector: deployContract
- Selector must be invoked with:
	- Blueprint's class hash
	- Constructor arguments
Internally uses the **deploy** syscall
Created by OZ as a public good and written in Cairo0

**Overview**
TX types:
- deploy_account
- declare
- invoke

TX lifecycle: 
- Received
- Succeeded
- Accepted on L2
- Accepted on L1 (final status)

Declare vs invoke => Class vs Instance
Deploy => Invoke Universal Deployer

### Validity Proofs
A use case of Zero Knowledge Proofs
- Convinces Verifies on L1 of new L2 state without sharing txs details
- It doesn't make L2 txs "private" 
- Makes verification efficient
- Validity proof => validity rollup
- Based on STARKs, not SNARKs
- Efficient proving and verification

### Why starknet?
- Optimized for ZK tech
- Allows for more computation power for less gas, very efficient
- Secured by STARKS + Ethereum
- Powerful programming language
- battle tested tech stack
- Withdraw assets to L1 in ~2hours

### Smart Wallets
Allows you to sign txs with TouchID or Face ID and execute multiple operations in a single tx
- On SN every wallet is a smart wallet, there are no EOAs
- Built using Account Abstraction 
- Providers: Argent and Braavos

Complex Interactions in a single transaction: Sometimes an action requires multiple steps (user operations)
- It's hard to ensure that multiple steps of an action are written in order, on the same block
	- In reality they might have other transactions in between steps or might have the steps on separate blocks
	- This opens way for an exploit! Maximal Extracted Value
- Multi Call on Starknet will put multiple user ops in a single transaction
	- Certainty that transactions happen in order, in same block

### Account Abstraction 
Decoupling of Signer and Account
**Signer**:
- Device that signs txs 
- Identifies user with PK
**Account**:
- Smart contract on starknet 
- Holds the assets
- Verifies signatures
- Execute txs with multi call

So the signer, for example a wallet or user with a wallet, invokes a transaction
That transaction pings the Account smart contract that might have some functions like is_valid_signature, validate, and execute. The execute function then directly calls the Target contract. 

Signature Verification
Programmable logic on the Account
Enables features like:
- Single Signer
- Multiple signers
- hardware signer
- social recovery
- session keys

Account abstraction + Secure Enclave
Using the part of your iphone's hardware dedicated to RNG, Crypto Key management, Hardware signer, Keychain / Touch ID / Face ID, as a hardware wallet => extra layer of security

### Why smart wallets?
- Better UX than regular wallets
- Multicall, hardware signer, social recovery, session keys
- Enabled by account abstraction
- Decoupling of signer and account
- Account is a smart contract with specific interface
- Supports signings txs with different *elliptic curves*

### Cairo
- Provable programming language 
- Syntax similar to Rust
- Compiles to Sierra (Safe Intermediate Representation)
- Sequencer compiles Sierra to "Safe CASM" (Cairo Assembly)
- Failed Transactions are included in blocks 
- Sequencer always compensated
- no more DoS vector as in Cairo0

### Declaring a smart contract
You have to declare new code, then deploy it, when working with StarkNet smart contracts
When your local machine compiles a cairo SC, it compiles into Sierra, then create a transaction
- When you create it, your wallet will declare the transaction in starknet by sending over the Sierra code to SN Sequencer's Mempool. From there it is compiled to CASM
- Something needs to be sent to the prover, like a proof of compilation
	- Proving compilation is tough since the compiler is written in Rust instead of Cairo 
Long Term Solution:
- Write the Cairo Compiler in Cairo
- Compilation can be proven
Short term Fix:
- Provide a hash of the CASM while declaring 
- Let Sequencer recompile Sierra -> Cairo
- Compare hashes

### Declaring vs Deploying 
- Declaring a SC registers its code on SN
- A declared SC is known as a contract class
- A contract class is identified by its class hash
- Contract classes are pure code (no storage)
- Contract instances can be derived from a contract class (like in OOP)
- Contract instance has storage
- Contract instance is identified by its address

### Universal Deployer
Smart Contract that deploys other smart contracts
- Only one selector: deployContract
Selector must be invoked with:
- Blueprint's class hash
- Constructor arguments
Internally uses the deploy syscall

### Summary of Part 1
- Cairo compiles to Sierra
- Sierra compiles to SafeCASM
- Declaring creates a Contract Class (CC)
- Contract instances are derived from CC
- A CC can be used as a library of functions
- CASM Hash used to prove compilation
- Deploying requires the universal deployer
- TX types: declare and invoke
